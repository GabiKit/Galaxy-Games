<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>Galaxy Games - Ultimate Hub</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #000; user-select: none; }
        
        /* --- UI LOBBY --- */
        #lobby-ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; align-items: center;
            z-index: 10;
        }
        h1.galaxy-title {
            font-size: 80px; color: transparent;
            background: linear-gradient(to right, #ff00cc, #3333ff, #00ccff);
            -webkit-background-clip: text; background-clip: text;
            text-shadow: 0 0 20px rgba(0, 100, 255, 0.5);
            margin-top: 50px; text-transform: uppercase; letter-spacing: 5px;
        }
        .subtitle { color: white; font-size: 20px; opacity: 0.8; margin-top: -40px; }

        /* --- WSPÓLNE ELEMENTY --- */
        #return-btn {
            display: none;
            position: absolute; top: 20px; right: 20px;
            padding: 10px 20px; background: #ff3333; color: white; border: none;
            cursor: pointer; font-weight: bold; border-radius: 5px;
            pointer-events: auto; z-index: 100; border: 2px solid white;
        }
        #return-btn:hover { background: #cc0000; }
        
        #tooltip {
            position: absolute; color: white; background: rgba(0,0,0,0.8);
            padding: 5px 10px; border-radius: 5px; pointer-events: none;
            display: none; transform: translate(-50%, -150%); border: 1px solid white;
            font-size: 14px; z-index: 20;
        }

        /* --- UI GRY 1: OBBY --- */
        #obby-ui {
            display: none; position: absolute; top: 20px; left: 20px;
            color: white; font-weight: bold; text-shadow: 2px 2px 0 #000; pointer-events: none; z-index: 10;
        }

        /* --- UI GRY 2: CLICKER --- */
        #clicker-ui {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, #222, #000);
            flex-direction: column; align-items: center; justify-content: center;
            z-index: 15; pointer-events: auto; color: white;
        }
        #clicker-btn {
            width: 200px; height: 200px; border-radius: 50%; background: orange;
            border: 5px solid #fff; font-size: 24px; cursor: pointer;
            transition: transform 0.1s; box-shadow: 0 0 50px orange;
        }
        #clicker-btn:active { transform: scale(0.95); }

        /* --- UI GRY 3: MINECRAFT --- */
        #minecraft-ui {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            border: 2px solid rgba(255,255,255,0.8); border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        .mc-info {
            position: absolute; bottom: 20px; left: 20px; color: white;
            font-family: monospace; font-size: 16px; background: rgba(0,0,0,0.5); padding: 10px;
        }
    </style>
</head>
<body>

    <div id="lobby-ui">
        <h1 class="galaxy-title">GALAXY GAMES</h1>
        <p class="subtitle">Wybierz grę</p>
    </div>

    <button id="return-btn">WRÓĆ DO LOBBY</button>
    <div id="tooltip"></div>

    <div id="obby-ui">
        <div id="score" style="font-size: 24px;">Level: 1</div>
        <div id="checkpoint-info" style="font-size: 14px; color: yellow; display:none;">ZAPISANO CHECKPOINT!</div>
        <div style="font-size: 14px; color: #ddd; margin-top: 5px;">WASD = Ruch | SPACJA = Skok</div>
    </div>

    <div id="clicker-ui">
        <h1 style="font-size: 50px; margin-bottom: 20px;">GABI CLICKER</h1>
        <div id="click-score" style="font-size: 40px; margin-bottom: 30px;">Punkty: 0</div>
        <button id="clicker-btn">KLIKNIJ MNIE!</button>
    </div>

    <div id="minecraft-ui">
        <div id="crosshair"></div>
        <div class="mc-info">LPM: Zniszcz | PPM: Buduj | WASD: Ruch</div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- KONFIGURACJA OBRAZKÓW ---
        // Jeśli nie dodasz tych plików na GitHub, portale będą po prostu kolorowe (i to też jest OK!)
        const IMAGE_OBBY = 'obby_icon.png';
        const IMAGE_CLICKER = 'clicker_icon.png';
        const IMAGE_MINECRAFT = 'minecraft_icon.png';

        // --- ZMIENNE GLOBALNE ---
        let scene, camera, renderer;
        let currentState = 'LOBBY'; 
        let stars, raycaster, mouse;
        let portals = [];
        
        // Zmienne Gry OBBY
        let playerGroup, platforms = [], obbyCheckpoint;
        let velocityY = 0, onGround = false;
        const keys = { w: false, a: false, s: false, d: false, space: false };
        let camTheta = Math.PI, camPhi = Math.PI / 3;

        // Zmienne Gry MINECRAFT
        let mcBlocks = [];
        let mcRaycaster;

        // Zmienne Gry CLICKER
        let clickScore = 0;

        // Inicjalizacja Renderera
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        document.body.appendChild(renderer.domElement);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // ------------------------------------------------------------------
        // --- 1. LOBBY ---
        // ------------------------------------------------------------------
        function initLobby() {
            currentState = 'LOBBY';
            // Pokaż/Ukryj UI
            document.getElementById('lobby-ui').style.display = 'flex';
            document.getElementById('return-btn').style.display = 'none';
            document.getElementById('obby-ui').style.display = 'none';
            document.getElementById('clicker-ui').style.display = 'none';
            document.getElementById('minecraft-ui').style.display = 'none';
            
            document.exitPointerLock();

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            scene.fog = new THREE.FogExp2(0x050510, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 11);

            const ambient = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambient);

            // Gwiazdy
            const starsGeo = new THREE.BufferGeometry();
            const posArray = new Float32Array(3000 * 3);
            for(let i=0; i<3000*3; i++) posArray[i] = (Math.random() - 0.5) * 120;
            starsGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            stars = new THREE.Points(starsGeo, new THREE.PointsMaterial({size: 0.12, color: 0xffffff}));
            scene.add(stars);

            // Ładowanie tekstur z obsługą błędów (żeby gra działała bez zdjęć)
            const texLoader = new THREE.TextureLoader();
            const loadTex = (path) => texLoader.load(path, undefined, undefined, (err) => console.log('Brak obrazka, używam koloru.'));

            const portalData = [
                { name: "RAINBOW OBBY", color: 0xaa00ff, map: loadTex(IMAGE_OBBY), action: initObby },
                { name: "CLICKER", color: 0xffaa00, map: loadTex(IMAGE_CLICKER), action: initClicker },
                { name: "MINECRAFT", color: 0x00aa00, map: loadTex(IMAGE_MINECRAFT), action: initMinecraft },
                { name: "WKRÓTCE", color: 0x333333, map: null, action: null }, // Tutaj będą Balony kiedyś
                { name: "ZABLOKOWANE", color: 0x222222, map: null, action: null },
            ];

            portals = [];
            for(let i=0; i<5; i++) {
                const geo = new THREE.SphereGeometry(1.3, 32, 32);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: portalData[i].map ? 0xffffff : portalData[i].color,
                    map: portalData[i].map,
                    roughness: 0.2, metalness: 0.4,
                    emissive: portalData[i].color, emissiveIntensity: 0.3
                });
                const sphere = new THREE.Mesh(geo, mat);
                const x = (i - 2) * 4; 
                sphere.position.set(x, 1.5, 0);
                
                // Napis nad portalem
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 256; canvas.height = 64;
                ctx.font = 'bold 30px Arial';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.fillText(portalData[i].name, 128, 40);
                const labelTex = new THREE.CanvasTexture(canvas);
                const label = new THREE.Sprite(new THREE.SpriteMaterial({map: labelTex}));
                label.position.set(0, 2, 0);
                label.scale.set(3, 0.75, 1);
                sphere.add(label);

                sphere.userData = { info: portalData[i] };
                scene.add(sphere);
                portals.push(sphere);

                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(1.6, 0.15, 16, 32),
                    new THREE.MeshStandardMaterial({ color: portalData[i].action ? 0x00ccff : 0x444444 })
                );
                ring.rotation.x = Math.PI / 2;
                ring.position.set(x, -0.5, 0);
                scene.add(ring);
            }
        }

        // ------------------------------------------------------------------
        // --- 2. GRA: OBBY ---
        // ------------------------------------------------------------------
        function initObby() {
            currentState = 'GAME_OBBY';
            document.getElementById('lobby-ui').style.display = 'none';
            document.getElementById('obby-ui').style.display = 'block';
            document.getElementById('return-btn').style.display = 'block';
            document.body.requestPointerLock();

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 80);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
            camTheta = Math.PI; camPhi = Math.PI / 3;

            scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.7));
            const dir = new THREE.DirectionalLight(0xffffff, 1.2);
            dir.position.set(30, 50, 30);
            dir.castShadow = true;
            dir.shadow.mapSize.set(2048, 2048);
            scene.add(dir);

            platforms = [];
            createPlatform(0, 0, 0, 6, 1, 6, 0xffffff, 'box'); 

            let curZ = -5;
            obbyCheckpoint = new THREE.Vector3(0, 2, 0);
            
            for(let i=0; i<600; i++) {
                const color = new THREE.Color().setHSL((i%40)/40, 0.9, 0.5);
                if (i > 0 && i % 40 === 0) {
                    createPlatform(0, 0, curZ - 3, 6, 1, 6, 0x111111, 'box', true);
                    curZ -= 8;
                    continue;
                }
                const type = Math.random();
                if (type < 0.4) { 
                    curZ -= 3.5; createPlatform(0, 0, curZ, 2.5, 0.6, 2.5, color, 'box');
                } else if (type < 0.7) {
                    curZ -= 3.8; createPlatform(0, 0, curZ, 2.5, 2.5, 2.5, color, 'sphere');
                } else {
                    curZ -= 4.0; createPlatform(0, 0, curZ, 1.2, 0.5, 3, color, 'box');
                }
            }
            createPlatform(0, 0, curZ - 10, 15, 1, 15, 0x00FF00, 'box'); // Meta
            createPlayer();
        }

        function createPlatform(x, y, z, w, h, d, color, shape='box', isCheckpoint=false) {
            let geo = shape === 'sphere' ? new THREE.SphereGeometry(w/2, 32, 32) : new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3 });
            if(isCheckpoint) { mat.emissive = 0x333333; mat.color.setHex(0x000000); }

            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            mesh.receiveShadow = true; mesh.castShadow = true;
            
            if(isCheckpoint) mesh.userData.isCheckpoint = true;
            mesh.userData.shape = shape;
            
            scene.add(mesh);
            platforms.push(mesh);
            return mesh;
        }

        function createPlayer() {
            playerGroup = new THREE.Group();
            const mY = new THREE.MeshStandardMaterial({color: 0xFFD700}); // Żółty
            const mB = new THREE.MeshStandardMaterial({color: 0x0044FF}); // Niebieski
            const mG = new THREE.MeshStandardMaterial({color: 0x44AA00}); // Zielony

            // Budowa ciała
            const torso = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 0.5), mB); torso.position.y = 1.5;
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), mY); head.position.y = 2.3;
            // Twarz (prymitywna)
            const face = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.1, 0.1), new THREE.MeshBasicMaterial({color:0x000000}));
            face.position.set(0, 2.3, -0.31); 
            head.add(face);

            const legL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1, 0.5), mG); legL.position.set(-0.25, 0.5, 0);
            const legR = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1, 0.5), mG); legR.position.set(0.25, 0.5, 0);
            const armL = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1, 0.3), mY); armL.position.set(-0.7, 1.5, 0);
            const armR = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1, 0.3), mY); armR.position.set(0.7, 1.5, 0);

            // Tworzymy grupę modelu, żeby go obrócić
            const model = new THREE.Group();
            model.add(torso, head, legL, legR, armL, armR);
            model.rotation.y = Math.PI; // OBRÓT O 180 STOPNI (Patrzy do przodu)
            
            playerGroup.add(model);
            
            // Cienie
            model.children.forEach(c => { if(c.isMesh) c.castShadow = true; });
            playerGroup.position.copy(obbyCheckpoint);
            scene.add(playerGroup);
        }

        // ------------------------------------------------------------------
        // --- 3. GRA: CLICKER ---
        // ------------------------------------------------------------------
        function initClicker() {
            currentState = 'GAME_CLICKER';
            document.getElementById('lobby-ui').style.display = 'none';
            document.getElementById('clicker-ui').style.display = 'flex';
            document.getElementById('return-btn').style.display = 'block';
            document.exitPointerLock();
            renderer.clear();
        }
        document.getElementById('clicker-btn').addEventListener('click', () => {
            clickScore++;
            document.getElementById('click-score').innerText = "Punkty: " + clickScore;
        });

        // ------------------------------------------------------------------
        // --- 4. GRA: MINECRAFT ---
        // ------------------------------------------------------------------
        function initMinecraft() {
            currentState = 'GAME_MINECRAFT';
            document.getElementById('lobby-ui').style.display = 'none';
            document.getElementById('minecraft-ui').style.display = 'block';
            document.getElementById('return-btn').style.display = 'block';
            document.body.requestPointerLock();

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 60);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
            camTheta = Math.PI; camPhi = Math.PI / 2;

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(10, 20, 10);
            scene.add(sun);

            mcBlocks = [];
            const grassMat = new THREE.MeshStandardMaterial({color: 0x44aa44});
            const geo = new THREE.BoxGeometry(1, 1, 1);
            
            for(let x=-8; x<8; x++) {
                for(let z=-8; z<8; z++) {
                    const block = new THREE.Mesh(geo, grassMat);
                    block.position.set(x, 0, z);
                    scene.add(block);
                    mcBlocks.push(block);
                }
            }
            mcRaycaster = new THREE.Raycaster();
            camera.position.set(0, 2, 0);
        }

        // --- OBSŁUGA STEROWANIA I KLIKANIA ---
        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            if (document.pointerLockElement === document.body) {
                camTheta -= e.movementX * 0.003;
                camPhi -= e.movementY * 0.003;
                camPhi = Math.max(0.1, Math.min(Math.PI - 0.1, camPhi));
            }
        });

        window.addEventListener('mousedown', (e) => {
            if (currentState === 'LOBBY') {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(portals);
                if (intersects.length > 0) {
                    const data = intersects[0].object.userData.info;
                    if (data.action) data.action();
                    else alert("Ta gra jest niedostępna (jeszcze!)");
                }
            } 
            else if (currentState === 'GAME_MINECRAFT' && document.pointerLockElement === document.body) {
                mcRaycaster.setFromCamera(new THREE.Vector2(0,0), camera);
                const intersects = mcRaycaster.intersectObjects(mcBlocks);
                if(intersects.length > 0) {
                    const hit = intersects[0];
                    if(e.button === 0) {
                        scene.remove(hit.object);
                        mcBlocks = mcBlocks.filter(b => b !== hit.object);
                    } else if (e.button === 2) {
                        const pos = hit.object.position.clone().add(hit.face.normal);
                        const newBlock = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color: 0x8b4513}));
                        newBlock.position.copy(pos);
                        scene.add(newBlock);
                        mcBlocks.push(newBlock);
                    }
                }
            }
            
            if (currentState !== 'LOBBY' && currentState !== 'GAME_CLICKER') {
                document.body.requestPointerLock();
            }
        });

        document.addEventListener('keydown', (e) => {
            if(e.code === 'KeyW') keys.w = true;
            if(e.code === 'KeyS') keys.s = true;
            if(e.code === 'KeyA') keys.a = true;
            if(e.code === 'KeyD') keys.d = true;
            if(e.code === 'Space') {
                if(currentState === 'GAME_OBBY' && onGround) { velocityY = 0.35; onGround = false; }
            }
        });
        document.addEventListener('keyup', (e) => {
            if(e.code === 'KeyW') keys.w = false;
            if(e.code === 'KeyS') keys.s = false;
            if(e.code === 'KeyA') keys.a = false;
            if(e.code === 'KeyD') keys.d = false;
        });

        document.getElementById('return-btn').addEventListener('click', initLobby);

        // --- GŁÓWNA PĘTLA ---
        function animate() {
            requestAnimationFrame(animate);

            if (currentState === 'LOBBY') {
                stars.rotation.y += 0.0005;
                portals.forEach(p => p.rotation.y += 0.01);
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(portals);
                const tooltip = document.getElementById('tooltip');
                if (intersects.length > 0) {
                    tooltip.style.display = 'block';
                    tooltip.style.left = (event.clientX + 10) + 'px';
                    tooltip.style.top = (event.clientY + 10) + 'px';
                    tooltip.innerText = intersects[0].object.userData.info.name;
                    document.body.style.cursor = 'pointer';
                } else {
                    tooltip.style.display = 'none';
                    document.body.style.cursor = 'default';
                }
                renderer.render(scene, camera);
            } 
            else if (currentState === 'GAME_CLICKER') {
                // HTML only
            }
            else if (currentState === 'GAME_MINECRAFT') {
                const speed = 0.1;
                const front = new THREE.Vector3(Math.sin(camTheta), 0, Math.cos(camTheta));
                const right = new THREE.Vector3(Math.sin(camTheta + Math.PI/2), 0, Math.cos(camTheta + Math.PI/2));
                if(keys.w) camera.position.add(front.multiplyScalar(-speed));
                if(keys.s) camera.position.add(front.multiplyScalar(speed));
                if(keys.a) camera.position.add(right.multiplyScalar(-speed));
                if(keys.d) camera.position.add(right.multiplyScalar(speed));
                camera.lookAt(camera.position.x - Math.sin(camTheta), camera.position.y + Math.cos(camPhi), camera.position.z - Math.cos(camTheta));
                renderer.render(scene, camera);
            }
            else if (currentState === 'GAME_OBBY') {
                const speed = 0.18;
                const forwardX = Math.sin(camTheta); const forwardZ = Math.cos(camTheta);
                const rightX = Math.sin(camTheta + Math.PI/2); const rightZ = Math.cos(camTheta + Math.PI/2);

                let dx = 0, dz = 0;
                if(keys.w) { dx -= forwardX; dz -= forwardZ; }
                if(keys.s) { dx += forwardX; dz += forwardZ; }
                if(keys.a) { dx -= rightX; dz -= rightZ; }
                if(keys.d) { dx += rightX; dz += rightZ; }

                if(dx !== 0 || dz !== 0) {
                    playerGroup.position.x += dx * speed;
                    playerGroup.position.z += dz * speed;
                    playerGroup.rotation.y = Math.atan2(dx, dz) + Math.PI; 
                    const t = Date.now() * 0.02;
                    const model = playerGroup.children[0];
                    model.children[2].rotation.x = Math.sin(t) * 0.8;
                    model.children[3].rotation.x = -Math.sin(t) * 0.8;
                }
                playerGroup.position.y += velocityY;
                velocityY -= 0.015; 
                onGround = false;
                const feetY = playerGroup.position.y;
                
                for(let p of platforms) {
                    if (Math.abs(p.position.z - playerGroup.position.z) > 8) continue;
                    const bounds = new THREE.Box3().setFromObject(p);
                    const margin = 0.8; 
                    if (playerGroup.position.x > bounds.min.x - margin && playerGroup.position.x < bounds.max.x + margin &&
                        playerGroup.position.z > bounds.min.z - margin && playerGroup.position.z < bounds.max.z + margin) {
                        if (feetY >= bounds.max.y - 0.5 && feetY <= bounds.max.y + 1.0 && velocityY <= 0) {
                            playerGroup.position.y = bounds.max.y; velocityY = 0; onGround = true;
                            if (p.userData.isCheckpoint && p.position.z < obbyCheckpoint.z - 2) { 
                                obbyCheckpoint.copy(playerGroup.position).add(new THREE.Vector3(0,0.1,0));
                                const info = document.getElementById('checkpoint-info');
                                info.style.display = 'block';
                                setTimeout(() => info.style.display = 'none', 2000);
                            }
                        }
                    }
                }
                if (playerGroup.position.y < -15) { playerGroup.position.copy(obbyCheckpoint); velocityY = 0; }
                const camDist = 6;
                camera.position.x = playerGroup.position.x + camDist * Math.sin(camPhi) * Math.sin(camTheta);
                camera.position.y = playerGroup.position.y + camDist * Math.cos(camPhi);
                camera.position.z = playerGroup.position.z + camDist * Math.sin(camPhi) * Math.cos(camTheta);
                camera.lookAt(playerGroup.position.x, playerGroup.position.y + 1.5, playerGroup.position.z);
                const lvl = Math.floor(Math.abs(playerGroup.position.z) / 4);
                document.getElementById('score').innerText = "Dystans: " + lvl + "m";
                renderer.render(scene, camera);
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        initLobby();
        animate();
    </script>
</body>
</html>
