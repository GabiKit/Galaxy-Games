<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>Galaxy Games - Wersja Pancerna</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #000; user-select: none; }
        
        /* UI LOBBY */
        #lobby-ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; align-items: center;
            z-index: 10;
        }
        h1.galaxy-title {
            font-size: 80px; color: transparent;
            background: linear-gradient(to right, #ff00cc, #3333ff, #00ccff);
            -webkit-background-clip: text; background-clip: text;
            text-shadow: 0 0 20px rgba(0, 100, 255, 0.5);
            margin-top: 50px; text-transform: uppercase; letter-spacing: 5px;
        }
        .subtitle { color: white; font-size: 20px; opacity: 0.8; margin-top: -40px; }

        /* UI GRY */
        #game-ui, #obby-ui, #minecraft-ui {
            display: none; position: absolute; top: 20px; left: 20px;
            color: white; font-weight: bold; text-shadow: 2px 2px 0 #000; pointer-events: none; z-index: 10;
        }
        
        #return-btn {
            display: none;
            position: absolute; top: 20px; right: 20px;
            padding: 10px 20px; background: #ff3333; color: white; border: none;
            cursor: pointer; font-weight: bold; border-radius: 5px;
            pointer-events: auto; z-index: 100; border: 2px solid white;
        }
        #return-btn:hover { background: #cc0000; }

        #clicker-ui {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, #222, #000);
            flex-direction: column; align-items: center; justify-content: center;
            z-index: 15; pointer-events: auto; color: white;
        }
        #clicker-btn {
            width: 200px; height: 200px; border-radius: 50%; background: orange;
            border: 5px solid #fff; font-size: 24px; cursor: pointer;
            transition: transform 0.1s; box-shadow: 0 0 50px orange;
        }
        #clicker-btn:active { transform: scale(0.95); }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            border: 2px solid rgba(255,255,255,0.8); border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* Debug info */
        #debug { position: absolute; bottom: 5px; left: 5px; color: gray; font-size: 10px; z-index: 5; }
    </style>
</head>
<body>

    <div id="lobby-ui">
        <h1 class="galaxy-title">GALAXY GAMES</h1>
        <p class="subtitle">Wybierz grę (Wersja 2.0)</p>
    </div>

    <button id="return-btn">WRÓĆ DO LOBBY</button>

    <div id="obby-ui">
        <div id="score" style="font-size: 24px;">Level: 1</div>
        <div style="font-size: 14px; color: #ddd;">WASD = Ruch | SPACJA = Skok</div>
    </div>

    <div id="clicker-ui">
        <h1>GABI CLICKER</h1>
        <h2 id="click-score">Punkty: 0</h2>
        <button id="clicker-btn">KLIK!</button>
    </div>

    <div id="minecraft-ui">
        <div id="crosshair"></div>
        <div style="position: absolute; bottom: 20px; left: 20px; color:white;">LPM: Zniszcz | PPM: Buduj</div>
    </div>
    
    <div id="debug">Ładowanie...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // Sprawdzenie czy Three.js działa
        if (typeof THREE === 'undefined') {
            document.getElementById('debug').innerText = "BŁĄD: Three.js nie załadowane!";
            alert("Błąd ładowania silnika gry. Sprawdź internet.");
        } else {
            document.getElementById('debug').innerText = "Silnik OK. Startuję...";
        }

        // --- ZMIENNE ---
        let scene, camera, renderer;
        let currentState = 'LOBBY';
        let portals = [];
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        
        // Gry
        let playerGroup, platforms = [], obbyCheckpoint = new THREE.Vector3(0,2,0);
        let velocityY = 0, onGround = false;
        let keys = {w:false, a:false, s:false, d:false};
        let camTheta = Math.PI, camPhi = Math.PI/3;
        
        let mcBlocks = [], mcRaycaster;
        let clickScore = 0;

        // Start
        init();

        function init() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            initLobby();
            animate();
        }

        function initLobby() {
            currentState = 'LOBBY';
            hideAllUI();
            document.getElementById('lobby-ui').style.display = 'flex';
            document.exitPointerLock();

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 11);

            const ambient = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambient);

            // Gwiazdy
            const starGeo = new THREE.BufferGeometry();
            const starPos = [];
            for(let i=0; i<3000; i++) starPos.push((Math.random()-0.5)*120, (Math.random()-0.5)*120, (Math.random()-0.5)*120);
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0xffffff, size: 0.1}));
            scene.add(stars);

            // Portale (KOLORY ZAMIAST ZDJĘĆ)
            portals = [];
            const data = [
                {name: "OBBY", color: 0xaa00ff, action: initObby},
                {name: "CLICKER", color: 0xffaa00, action: initClicker},
                {name: "MINECRAFT", color: 0x00aa00, action: initMinecraft},
                {name: "WKRÓTCE", color: 0x555555, action: null},
                {name: "LOCKED", color: 0x222222, action: null}
            ];

            for(let i=0; i<5; i++) {
                const sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(1.3, 32, 32),
                    new THREE.MeshStandardMaterial({
                        color: data[i].color, roughness: 0.2, metalness: 0.5,
                        emissive: data[i].color, emissiveIntensity: 0.3
                    })
                );
                sphere.position.set((i-2)*4, 1.5, 0);
                sphere.userData = {info: data[i]};
                scene.add(sphere);
                portals.push(sphere);

                // Napis (Prosty sprite canvas)
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 256; canvas.height = 64;
                ctx.font = 'bold 40px Arial';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.fillText(data[i].name, 128, 48);
                const tex = new THREE.CanvasTexture(canvas);
                const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map: tex}));
                sprite.position.set(0, 2, 0);
                sprite.scale.set(3, 0.75, 1);
                sphere.add(sprite);
            }
        }

        function initObby() {
            currentState = 'OBBY';
            hideAllUI();
            document.getElementById('obby-ui').style.display = 'block';
            document.getElementById('return-btn').style.display = 'block';
            document.body.requestPointerLock();

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
            camTheta = Math.PI; camPhi = Math.PI/3;

            scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.8));
            const sun = new THREE.DirectionalLight(0xffffff, 1);
            sun.position.set(10, 20, 10);
            scene.add(sun);

            platforms = [];
            createPlatform(0, 0, 0, 6, 1, 6, 0xffffff); // Start

            let z = -5;
            obbyCheckpoint.set(0,2,0);
            for(let i=0; i<300; i++) {
                const col = new THREE.Color().setHSL((i%20)/20, 0.8, 0.5);
                if(i>0 && i%30===0) {
                    createPlatform(0, 0, z-3, 6, 1, 6, 0x111111, true); // Checkpoint
                    z-=8; continue;
                }
                const r = Math.random();
                if(r<0.4) { z-=3.5; createPlatform(0,0,z, 2.5,0.5,2.5, col); }
                else if(r<0.7) { z-=3.8; createPlatform(0,0,z, 2.5,2.5,2.5, col, true); } // Kulka
                else { z-=4.0; createPlatform(0,0,z, 1.5,0.5,4, col); }
            }
            createPlatform(0,0,z-10, 15,1,15, 0x00ff00); // Meta
            createPlayer();
        }

        function createPlatform(x,y,z,w,h,d,col, isSphere=false) {
            let geo = isSphere ? new THREE.SphereGeometry(w/2, 32, 32) : new THREE.BoxGeometry(w,h,d);
            const mat = new THREE.MeshStandardMaterial({color: col});
            if(col === 0x111111) { mat.emissive = 0x222222; mat.userData = {checkpoint:true}; }
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x,y,z);
            scene.add(mesh);
            platforms.push(mesh);
        }

        function createPlayer() {
            playerGroup = new THREE.Group();
            const matY = new THREE.MeshStandardMaterial({color: 0xffff00});
            const matB = new THREE.MeshStandardMaterial({color: 0x0000ff});
            const matG = new THREE.MeshStandardMaterial({color: 0x00ff00});
            
            const torso = new THREE.Mesh(new THREE.BoxGeometry(1,1,0.5), matB); torso.position.y=1.5;
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.6,0.6), matY); head.position.y=2.3;
            const legL = new THREE.Mesh(new THREE.BoxGeometry(0.4,1,0.5), matG); legL.position.set(-0.25,0.5,0);
            const legR = new THREE.Mesh(new THREE.BoxGeometry(0.4,1,0.5), matG); legR.position.set(0.25,0.5,0);
            
            const model = new THREE.Group();
            model.add(torso, head, legL, legR);
            model.rotation.y = Math.PI; // Tyłem
            playerGroup.add(model);
            playerGroup.position.copy(obbyCheckpoint);
            scene.add(playerGroup);
        }

        function initClicker() {
            currentState = 'CLICKER';
            hideAllUI();
            document.getElementById('clicker-ui').style.display = 'flex';
            document.getElementById('return-btn').style.display = 'block';
            document.exitPointerLock();
            renderer.clear();
        }

        function initMinecraft() {
            currentState = 'MINECRAFT';
            hideAllUI();
            document.getElementById('minecraft-ui').style.display = 'block';
            document.getElementById('return-btn').style.display = 'block';
            document.body.requestPointerLock();
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
            camTheta = Math.PI; camPhi = Math.PI/2;
            
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(10,20,10); scene.add(sun);
            
            mcBlocks = [];
            const mat = new THREE.MeshStandardMaterial({color: 0x44aa44});
            const geo = new THREE.BoxGeometry(1,1,1);
            for(let x=-5; x<5; x++) for(let z=-5; z<5; z++) {
                const b = new THREE.Mesh(geo, mat);
                b.position.set(x,0,z);
                scene.add(b);
                mcBlocks.push(b);
            }
            mcRaycaster = new THREE.Raycaster();
            camera.position.set(0,2,0);
        }

        function hideAllUI() {
            document.getElementById('lobby-ui').style.display = 'none';
            document.getElementById('obby-ui').style.display = 'none';
            document.getElementById('clicker-ui').style.display = 'none';
            document.getElementById('minecraft-ui').style.display = 'none';
            document.getElementById('return-btn').style.display = 'none';
        }

        // STEROWANIE
        document.getElementById('return-btn').addEventListener('click', initLobby);
        document.getElementById('clicker-btn').addEventListener('click', () => {
            clickScore++;
            document.getElementById('click-score').innerText = "Punkty: " + clickScore;
        });

        document.addEventListener('keydown', e => {
            if(e.code==='KeyW') keys.w=true; if(e.code==='KeyS') keys.s=true;
            if(e.code==='KeyA') keys.a=true; if(e.code==='KeyD') keys.d=true;
            if(e.code==='Space' && currentState==='OBBY' && onGround) { velocityY=0.35; onGround=false; }
        });
        document.addEventListener('keyup', e => {
            if(e.code==='KeyW') keys.w=false; if(e.code==='KeyS') keys.s=false;
            if(e.code==='KeyA') keys.a=false; if(e.code==='KeyD') keys.d=false;
        });

        window.addEventListener('mousemove', e => {
            if(document.pointerLockElement === document.body) {
                camTheta -= e.movementX * 0.003;
                camPhi -= e.movementY * 0.003;
                if(camPhi < 0.1) camPhi = 0.1;
                if(camPhi > Math.PI-0.1) camPhi = Math.PI-0.1;
            }
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        window.addEventListener('mousedown', e => {
            if(currentState === 'LOBBY') {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(portals);
                if(intersects.length > 0) {
                    const info = intersects[0].object.userData.info;
                    if(info.action) info.action();
                }
            } else if (currentState === 'MINECRAFT' && document.pointerLockElement) {
                mcRaycaster.setFromCamera(new THREE.Vector2(0,0), camera);
                const hits = mcRaycaster.intersectObjects(mcBlocks);
                if(hits.length > 0) {
                    const hit = hits[0];
                    if(e.button === 0) { // Lewy
                        scene.remove(hit.object);
                        mcBlocks = mcBlocks.filter(b => b!==hit.object);
                    } else if (e.button === 2) { // Prawy
                        const pos = hit.object.position.clone().add(hit.face.normal);
                        const b = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color: 0x8b4513}));
                        b.position.copy(pos);
                        scene.add(b);
                        mcBlocks.push(b);
                    }
                }
            }
            
            if(currentState !== 'LOBBY' && currentState !== 'CLICKER') document.body.requestPointerLock();
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);

            if(currentState === 'LOBBY') {
                portals.forEach(p => p.rotation.y += 0.01);
                raycaster.setFromCamera(mouse, camera);
                const hits = raycaster.intersectObjects(portals);
                document.body.style.cursor = hits.length > 0 ? 'pointer' : 'default';
                renderer.render(scene, camera);
            } 
            else if(currentState === 'OBBY') {
                // Ruch
                const dx = (Number(keys.d)-Number(keys.a));
                const dz = (Number(keys.s)-Number(keys.w));
                
                const sin = Math.sin(camTheta), cos = Math.cos(camTheta);
                
                if(dx!==0 || dz!==0) {
                    const vx = (dx*cos + dz*sin)*0.18;
                    const vz = (-dx*sin + dz*cos)*0.18;
                    playerGroup.position.x += vx;
                    playerGroup.position.z += vz;
                    playerGroup.rotation.y = Math.atan2(vx, vz) + Math.PI;

                    // Animacja
                    const t = Date.now()*0.02;
                    playerGroup.children[0].children[2].rotation.x = Math.sin(t);
                    playerGroup.children[0].children[3].rotation.x = -Math.sin(t);
                }

                // Fizyka
                playerGroup.position.y += velocityY;
                velocityY -= 0.015;
                onGround = false;

                const feetY = playerGroup.position.y;
                for(let p of platforms) {
                    if(Math.abs(p.position.z - playerGroup.position.z) > 6) continue;
                    // Prosta kolizja AABB
                    const w = p.geometry.parameters.radius ? p.geometry.parameters.radius*2 : p.geometry.parameters.width;
                    const d = p.geometry.parameters.radius ? p.geometry.parameters.radius*2 : p.geometry.parameters.depth;
                    
                    if(playerGroup.position.x > p.position.x - w/2 - 0.5 && 
                       playerGroup.position.x < p.position.x + w/2 + 0.5 &&
                       playerGroup.position.z > p.position.z - d/2 - 0.5 &&
                       playerGroup.position.z < p.position.z + d/2 + 0.5) {
                           
                           if(feetY >= p.position.y+0.4 && feetY <= p.position.y+2.0 && velocityY<=0) {
                               velocityY = 0;
                               playerGroup.position.y = p.position.y + (p.geometry.parameters.height || w)/2 + 1.5;
                               onGround = true;
                               // Checkpoint
                               if(p.userData.checkpoint && p.position.z < obbyCheckpoint.z-2) {
                                   obbyCheckpoint.copy(playerGroup.position).add(new THREE.Vector3(0,0.1,0));
                               }
                           }
                       }
                }

                if(playerGroup.position.y < -10) {
                    playerGroup.position.copy(obbyCheckpoint);
                    velocityY = 0;
                }

                // Kamera
                const cd = 6;
                camera.position.set(
                    playerGroup.position.x + Math.sin(camTheta)*Math.sin(camPhi)*cd,
                    playerGroup.position.y + Math.cos(camPhi)*cd,
                    playerGroup.position.z + Math.cos(camTheta)*Math.sin(camPhi)*cd
                );
                camera.lookAt(playerGroup.position.x, playerGroup.position.y+1.5, playerGroup.position.z);
                renderer.render(scene, camera);
            }
            else if(currentState === 'MINECRAFT') {
                const s = 0.1;
                const sin = Math.sin(camTheta), cos = Math.cos(camTheta);
                if(keys.w) { camera.position.x-=s*sin; camera.position.z-=s*cos; }
                if(keys.s) { camera.position.x+=s*sin; camera.position.z+=s*cos; }
                if(keys.a) { camera.position.x-=s*cos; camera.position.z+=s*sin; }
                if(keys.d) { camera.position.x+=s*cos; camera.position.z-=s*sin; }
                
                const tx = camera.position.x - sin;
                const ty = camera.position.y + Math.cos(camPhi);
                const tz = camera.position.z - cos;
                camera.lookAt(tx, ty, tz);
                renderer.render(scene, camera);
            }
        }
    </script>
</body>
</html>
