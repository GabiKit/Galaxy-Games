<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>Galaxy Games - Ultimate Hub</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #000; user-select: none; }
        
        /* --- UI LOBBY --- */
        #lobby-ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; align-items: center;
            z-index: 10;
        }
        h1.galaxy-title {
            font-size: 80px; color: transparent;
            background: linear-gradient(to right, #ff00cc, #3333ff, #00ccff);
            -webkit-background-clip: text; background-clip: text;
            text-shadow: 0 0 20px rgba(0, 100, 255, 0.5);
            margin-top: 50px; text-transform: uppercase; letter-spacing: 5px;
        }
        .subtitle { color: white; font-size: 20px; opacity: 0.8; margin-top: -40px; }

        /* --- WSPÓLNE --- */
        #return-btn {
            display: none; position: absolute; top: 20px; right: 20px;
            padding: 10px 20px; background: #ff3333; color: white; border: none;
            cursor: pointer; font-weight: bold; border-radius: 5px;
            pointer-events: auto; z-index: 1000; border: 2px solid white;
        }
        #return-btn:hover { background: #cc0000; }
        
        #tooltip {
            position: absolute; color: white; background: rgba(0,0,0,0.8);
            padding: 5px 10px; border-radius: 5px; pointer-events: none;
            display: none; transform: translate(-50%, -150%); border: 1px solid white;
            font-size: 14px; z-index: 20;
        }

        /* --- UI OBBY --- */
        #obby-ui { display: none; position: absolute; top: 20px; left: 20px; color: white; font-weight: bold; z-index: 10; pointer-events: none; }
        
        /* --- UI CLICKER --- */
        #clicker-ui {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, #222, #000);
            flex-direction: column; align-items: center; justify-content: center;
            z-index: 15; pointer-events: auto; color: white;
        }
        #clicker-btn {
            width: 200px; height: 200px; border-radius: 50%; background: orange;
            border: 5px solid #fff; font-size: 24px; cursor: pointer;
            box-shadow: 0 0 50px orange; transition: transform 0.1s;
        }
        #clicker-btn:active { transform: scale(0.95); }

        /* --- UI MINECRAFT 3D --- */
        #minecraft-ui { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 15; pointer-events: none; }
        #mc-crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            border: 2px solid rgba(255,255,255,0.8); border-radius: 50%; transform: translate(-50%, -50%);
        }
        #mc-hotbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 5px; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 5px;
        }
        .mc-slot {
            width: 50px; height: 50px; border: 3px solid #555; background: #222;
            display: flex; align-items: center; justify-content: center;
            color: white; font-weight: bold; font-family: monospace; font-size: 20px;
        }
        .mc-slot.active { border-color: white; transform: scale(1.1); }
        .mc-info { position: absolute; top: 20px; left: 20px; color: white; font-family: monospace; text-shadow: 1px 1px 0 #000; }
    </style>
</head>
<body>

    <div id="lobby-ui">
        <h1 class="galaxy-title">GALAXY GAMES</h1>
        <p class="subtitle">Wybierz grę</p>
    </div>

    <button id="return-btn">WRÓĆ DO LOBBY</button>
    <div id="tooltip"></div>

    <div id="obby-ui">
        <div id="score" style="font-size: 24px;">Level: 1</div>
        <div id="checkpoint-info" style="font-size: 14px; color: yellow; display:none;">ZAPISANO CHECKPOINT!</div>
    </div>

    <div id="clicker-ui">
        <h1>GABI CLICKER</h1>
        <h2 id="click-score">Punkty: 0</h2>
        <button id="clicker-btn">KLIK!</button>
    </div>

    <div id="minecraft-ui">
        <div id="mc-crosshair"></div>
        <div class="mc-info">
            BlockCraft 1.0<br>
            WASD = Ruch | SPACJA = Skok<br>
            LPM = Zniszcz | PPM = Buduj<br>
            1-5 = Zmień blok
        </div>
        <div id="mc-hotbar">
            <div class="mc-slot active" id="slot1">1</div>
            <div class="mc-slot" id="slot2">2</div>
            <div class="mc-slot" id="slot3">3</div>
            <div class="mc-slot" id="slot4">4</div>
            <div class="mc-slot" id="slot5">5</div>
        </div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- KONFIGURACJA OBRAZKÓW ---
        const IMAGE_OBBY = 'obby_icon.png';
        const IMAGE_CLICKER = 'clicker_icon.png';
        const IMAGE_MINECRAFT = 'minecraft_icon.png';

        // --- ZMIENNE GŁÓWNE ---
        let scene, camera, renderer;
        let currentState = 'LOBBY';
        let portals = [], raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();
        
        // ZMIENNE OBBY
        let playerGroup, platforms = [], obbyCheckpoint = new THREE.Vector3(0, 2, 0);
        let velocityY = 0, onGround = false;
        let keys = {w:false, a:false, s:false, d:false, space:false};
        let camTheta = Math.PI, camPhi = Math.PI/3;

        // ZMIENNE MINECRAFT
        let mcWorld = {}; // Mapa bloków: "x,y,z" -> mesh
        let mcSelectedBlock = 1; // 1=Grass, 2=Dirt, 3=Stone, 4=Plank, 5=Brick
        let mcTime = 0; // Czas dnia
        let mcSun, mcAmbient;
        
        // ZMIENNE CLICKER
        let clickScore = 0;

        // --- SYSTEM GENEROWANIA TEKSTUR MINECRAFTA (Proceduralny Pixel Art) ---
        function createBlockTexture(color, noiseIntensity) {
            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color;
            ctx.fillRect(0,0,size,size);
            
            // Dodaj szum (piksele)
            for(let i=0; i<400; i++) {
                const x = Math.floor(Math.random()*size);
                const y = Math.floor(Math.random()*size);
                ctx.fillStyle = Math.random() > 0.5 ? 'rgba(0,0,0,0.1)' : 'rgba(255,255,255,0.1)';
                ctx.fillRect(x,y,4,4); // Pixel size 4x4
            }
            // Ramka dla desek/cegieł
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 4;
            ctx.strokeRect(0,0,size,size);

            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter; // Pixelated look
            return tex;
        }

        // Materiały bloków (Generowane w locie!)
        const mcMaterials = {
            1: new THREE.MeshStandardMaterial({ map: createBlockTexture('#55aa55', 0.1) }), // Trawa
            2: new THREE.MeshStandardMaterial({ map: createBlockTexture('#8b4513', 0.1) }), // Ziemia
            3: new THREE.MeshStandardMaterial({ map: createBlockTexture('#777777', 0.1) }), // Kamień
            4: new THREE.MeshStandardMaterial({ map: createBlockTexture('#e0c080', 0.1) }), // Deski
            5: new THREE.MeshStandardMaterial({ map: createBlockTexture('#aa4444', 0.1) }), // Cegły
            6: new THREE.MeshStandardMaterial({ map: createBlockTexture('#654321', 0.1) }), // Drewno (Pien)
            7: new THREE.MeshStandardMaterial({ map: createBlockTexture('#228b22', 0.1), transparent:true, opacity:0.9 }), // Liście
        };

        // START
        init();

        function init() {
            renderer = new THREE.WebGLRenderer({ antialias: false }); // False dla retro looku
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            initLobby();
            animate();
        }

        // --- LOBBY ---
        function initLobby() {
            switchState('LOBBY');
            document.exitPointerLock();
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            scene.fog = new THREE.FogExp2(0x050510, 0.02);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 11);
            
            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            
            // Gwiazdy
            const starsGeo = new THREE.BufferGeometry();
            const starsPos = [];
            for(let i=0; i<3000; i++) starsPos.push((Math.random()-0.5)*120, (Math.random()-0.5)*120, (Math.random()-0.5)*120);
            starsGeo.setAttribute('position', new THREE.Float32BufferAttribute(starsPos, 3));
            scene.add(new THREE.Points(starsGeo, new THREE.PointsMaterial({color: 0xffffff, size: 0.1})));

            // Portale
            const texLoader = new THREE.TextureLoader();
            const loadTex = (p) => texLoader.load(p, undefined, undefined, () => {});
            
            portals = [];
            const data = [
                {name: "OBBY", color: 0xaa00ff, map: loadTex(IMAGE_OBBY), action: initObby},
                {name: "CLICKER", color: 0xffaa00, map: loadTex(IMAGE_CLICKER), action: initClicker},
                {name: "MINECRAFT", color: 0x00aa00, map: loadTex(IMAGE_MINECRAFT), action: initMinecraft},
                {name: "WKRÓTCE", color: 0x333333, map: null, action: null},
                {name: "ZABLOKOWANE", color: 0x222222, map: null, action: null}
            ];

            for(let i=0; i<5; i++) {
                const geo = new THREE.SphereGeometry(1.3, 32, 32);
                const mat = new THREE.MeshStandardMaterial({
                    color: data[i].map ? 0xffffff : data[i].color, map: data[i].map,
                    roughness: 0.2, metalness: 0.4, emissive: data[i].color, emissiveIntensity: 0.3
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set((i-2)*4, 1.5, 0);
                mesh.userData = {info: data[i]};
                scene.add(mesh);
                portals.push(mesh);

                // Napis 3D
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width=256; canvas.height=64;
                ctx.font="bold 40px Arial"; ctx.fillStyle="white"; ctx.textAlign="center";
                ctx.fillText(data[i].name, 128, 48);
                const sp = new THREE.Sprite(new THREE.SpriteMaterial({map: new THREE.CanvasTexture(canvas)}));
                sp.position.set(0, 2, 0); sp.scale.set(3, 0.75, 1);
                mesh.add(sp);

                const ring = new THREE.Mesh(new THREE.TorusGeometry(1.6, 0.15, 16, 32), new THREE.MeshStandardMaterial({color: data[i].action ? 0x00ccff : 0x444444}));
                ring.rotation.x = Math.PI/2; ring.position.set((i-2)*4, -0.5, 0);
                scene.add(ring);
            }
        }

        // --- OBBY (TRUDNIEJSZE!) ---
        function initObby() {
            switchState('OBBY');
            document.body.requestPointerLock();
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 80);
            camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
            camTheta = Math.PI; camPhi = Math.PI/3;

            scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.7));
            const dir = new THREE.DirectionalLight(0xffffff, 1.2);
            dir.position.set(30, 50, 30);
            dir.castShadow = true;
            dir.shadow.mapSize.set(2048, 2048);
            scene.add(dir);

            platforms = [];
            createPlatform(0,0,0, 6,1,6, 0xffffff, 'box'); // Start

            let z = -5;
            obbyCheckpoint.set(0, 2, 0);
            
            for(let i=0; i<600; i++) {
                const col = new THREE.Color().setHSL((i%40)/40, 0.9, 0.5);
                if(i>0 && i%40===0) {
                    createPlatform(0,0,z-3, 6,1,6, 0x111111, 'box', true);
                    z-=8; continue;
                }
                const r = Math.random();
                // HARDCORE MODE: Większe przerwy (z-=5.0)
                if(r<0.4) { z-=5.0; createPlatform(0,0,z, 2.0,0.5,2.0, col, 'box'); } // Mniejsze bloki
                else if(r<0.7) { z-=5.0; createPlatform(0,0,z, 2.0,2.0,2.0, col, 'sphere'); } // Kulki
                else { z-=5.5; createPlatform(0,0,z, 0.8,0.5,4.0, col, 'box'); } // Bardzo wąska belka
            }
            createPlatform(0,0,z-10, 15,1,15, 0x00ff00, 'box');
            createPlayer();
        }

        function createPlatform(x,y,z,w,h,d,col,shape,isCheck=false) {
            let geo = shape==='sphere' ? new THREE.SphereGeometry(w/2, 32, 32) : new THREE.BoxGeometry(w,h,d);
            const mat = new THREE.MeshStandardMaterial({color: col, roughness: 0.3});
            if(isCheck) { mat.emissive = 0x333333; mat.color.setHex(0x000000); }
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x,y,z);
            mesh.receiveShadow = true; mesh.castShadow = true;
            if(isCheck) mesh.userData.checkpoint = true;
            scene.add(mesh);
            platforms.push(mesh);
        }

        function createPlayer() {
            playerGroup = new THREE.Group();
            const mY = new THREE.MeshStandardMaterial({color: 0xFFD700});
            const mB = new THREE.MeshStandardMaterial({color: 0x0044FF});
            const mG = new THREE.MeshStandardMaterial({color: 0x44AA00});

            const model = new THREE.Group();
            const torso = new THREE.Mesh(new THREE.BoxGeometry(1,1,0.5), mB); torso.position.y=1.5;
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.6,0.6), mY); head.position.y=2.3;
            const legL = new THREE.Mesh(new THREE.BoxGeometry(0.4,1,0.5), mG); legL.position.set(-0.25,0.5,0);
            const legR = new THREE.Mesh(new THREE.BoxGeometry(0.4,1,0.5), mG); legR.position.set(0.25,0.5,0);
            const armL = new THREE.Mesh(new THREE.BoxGeometry(0.3,1,0.3), mY); armL.position.set(-0.7,1.5,0);
            const armR = new THREE.Mesh(new THREE.BoxGeometry(0.3,1,0.3), mY); armR.position.set(0.7,1.5,0);
            
            model.add(torso, head, legL, legR, armL, armR);
            model.rotation.y = Math.PI; // Tyłem
            model.scale.set(0.6, 0.6, 0.6); // Mały gracz

            playerGroup.add(model);
            playerGroup.children[0].children.forEach(c => c.castShadow = true);
            playerGroup.position.copy(obbyCheckpoint);
            scene.add(playerGroup);
        }

        // --- MINECRAFT 3D (BLOCKCRAFT) ---
        function initMinecraft() {
            switchState('MINECRAFT');
            document.body.requestPointerLock();
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 60);
            
            // Kamera FPS
            camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
            camTheta = Math.PI; camPhi = Math.PI/2; 
            camera.position.set(0, 5, 0); // Start wysoko

            // Światło (Dzień/Noc)
            mcAmbient = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(mcAmbient);
            mcSun = new THREE.DirectionalLight(0xffffff, 1);
            mcSun.position.set(50, 100, 50);
            mcSun.castShadow = true;
            mcSun.shadow.mapSize.set(2048, 2048);
            scene.add(mcSun);

            // Generowanie Świata 3D
            mcWorld = {}; // Reset
            const boxGeo = new THREE.BoxGeometry(1,1,1);
            
            // Podłoga 16x16
            for(let x=-16; x<16; x++) {
                for(let z=-16; z<16; z++) {
                    // Proceduralna wysokość (pseudo-losowa)
                    let h = Math.floor(Math.sin(x*0.3)*2 + Math.cos(z*0.3)*2);
                    if(h < 0) h = 0;
                    
                    // Stawianie słupa bloków
                    for(let y=0; y<=h; y++) {
                        let type = 2; // Ziemia
                        if(y === h) type = 1; // Trawa na górze
                        if(y < h-2) type = 3; // Kamień głęboko
                        mcPlaceBlock(x, y, z, type);
                    }

                    // Drzewa (losowo)
                    if(x%5===0 && z%5===0 && Math.random()>0.3) {
                        mcPlaceBlock(x, h+1, z, 6); // Pien
                        mcPlaceBlock(x, h+2, z, 6);
                        mcPlaceBlock(x, h+3, z, 6);
                        // Liście
                        for(let lx=-1; lx<=1; lx++) for(let lz=-1; lz<=1; lz++) {
                            mcPlaceBlock(x+lx, h+3, z+lz, 7);
                            if(Math.abs(lx)!==1 || Math.abs(lz)!==1) mcPlaceBlock(x+lx, h+4, z+lz, 7);
                        }
                    }
                }
            }
        }

        function mcPlaceBlock(x, y, z, type) {
            const key = x+','+y+','+z;
            if(mcWorld[key]) return; // Już zajęte

            const mesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), mcMaterials[type]);
            mesh.position.set(x, y, z);
            mesh.castShadow = true; mesh.receiveShadow = true;
            mesh.userData = { isBlock: true, type: type };
            
            scene.add(mesh);
            mcWorld[key] = mesh;
        }

        function mcRemoveBlock(mesh) {
            const key = mesh.position.x+','+mesh.position.y+','+mesh.position.z;
            delete mcWorld[key];
            scene.remove(mesh);
        }

        // --- CYKL DNIA I NOCY ---
        function mcUpdateDayCycle() {
            if(currentState !== 'MINECRAFT') return;
            mcTime += 0.002;
            const sunY = Math.sin(mcTime) * 100;
            const sunX = Math.cos(mcTime) * 100;
            mcSun.position.set(sunX, sunY, 50);
            
            // Kolor nieba
            if(sunY > 0) { // Dzień
                scene.background.setHSL(0.6, 0.5, 0.5 + sunY/200);
                mcAmbient.intensity = 0.5;
            } else { // Noc
                scene.background.setHex(0x000010);
                mcAmbient.intensity = 0.1;
            }
        }

        // --- CLICKER ---
        function initClicker() {
            switchState('CLICKER');
            renderer.clear();
        }

        function switchState(newState) {
            currentState = newState;
            // UI Update
            ['lobby-ui','obby-ui','clicker-ui','minecraft-ui','return-btn'].forEach(id => document.getElementById(id).style.display = 'none');
            
            if(newState==='LOBBY') document.getElementById('lobby-ui').style.display = 'flex';
            if(newState==='OBBY') { document.getElementById('obby-ui').style.display = 'block'; document.getElementById('return-btn').style.display = 'block'; }
            if(newState==='CLICKER') { document.getElementById('clicker-ui').style.display = 'flex'; document.getElementById('return-btn').style.display = 'block'; }
            if(newState==='MINECRAFT') { document.getElementById('minecraft-ui').style.display = 'block'; document.getElementById('return-btn').style.display = 'block'; }
        }

        // --- EVENTS ---
        document.getElementById('return-btn').addEventListener('click', initLobby);
        document.getElementById('clicker-btn').addEventListener('click', () => { clickScore++; document.getElementById('click-score').innerText="Punkty: "+clickScore; });

        // Wybór w hotbarze (1-5)
        window.addEventListener('keydown', e => {
            if(e.code==='KeyW') keys.w=true; if(e.code==='KeyS') keys.s=true;
            if(e.code==='KeyA') keys.a=true; if(e.code==='KeyD') keys.d=true;
            if(e.code==='Space') {
                if(currentState==='OBBY' && onGround) { velocityY=0.35; onGround=false; }
            }
            if(currentState==='MINECRAFT') {
                if(e.key >= '1' && e.key <= '5') {
                    mcSelectedBlock = parseInt(e.key);
                    document.querySelectorAll('.mc-slot').forEach(s => s.classList.remove('active'));
                    document.getElementById('slot'+mcSelectedBlock).classList.add('active');
                }
            }
        });
        window.addEventListener('keyup', e => {
            if(e.code==='KeyW') keys.w=false; if(e.code==='KeyS') keys.s=false;
            if(e.code==='KeyA') keys.a=false; if(e.code==='KeyD') keys.d=false;
        });

        window.addEventListener('mousemove', e => {
            if(document.pointerLockElement===document.body) {
                camTheta -= e.movementX*0.003;
                camPhi -= e.movementY*0.003;
                if(camPhi<0.1) camPhi=0.1; if(camPhi>Math.PI-0.1) camPhi=Math.PI-0.1;
            }
            mouse.x = (e.clientX/window.innerWidth)*2-1; mouse.y = -(e.clientY/window.innerHeight)*2+1;
        });

        window.addEventListener('mousedown', e => {
            if(currentState==='LOBBY') {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(portals);
                if(intersects.length>0 && intersects[0].object.userData.info.action) intersects[0].object.userData.info.action();
            }
            else if(currentState==='MINECRAFT' && document.pointerLockElement) {
                raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
                const intersects = raycaster.intersectObjects(scene.children);
                // Szukamy najbliższego bloku
                let hit = null;
                for(let i=0; i<intersects.length; i++) {
                    if(intersects[i].object.userData.isBlock) { hit = intersects[i]; break; }
                }

                if(hit) {
                    if(e.button === 0) { // Lewy: Zniszcz
                        mcRemoveBlock(hit.object);
                    } else if (e.button === 2) { // Prawy: Postaw
                        const p = hit.point.add(hit.face.normal.multiplyScalar(0.5)).floor().addScalar(0.5); // Grid snap
                        // Mapowanie slotu na ID bloku:
                        // 1=Trawa, 2=Ziemia, 3=Kamień, 4=Deski, 5=Cegły
                        mcPlaceBlock(Math.round(p.x), Math.round(p.y), Math.round(p.z), mcSelectedBlock);
                    }
                }
            }
            if(currentState!=='LOBBY' && currentState!=='CLICKER') document.body.requestPointerLock();
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);

            if(currentState==='LOBBY') {
                portals.forEach(p => p.rotation.y += 0.01);
                raycaster.setFromCamera(mouse, camera);
                const hits = raycaster.intersectObjects(portals);
                document.body.style.cursor = hits.length>0 ? 'pointer' : 'default';
                const t = document.getElementById('tooltip');
                if(hits.length>0) {t.style.display='block'; t.style.left=(event.clientX+10)+'px'; t.style.top=(event.clientY+10)+'px'; t.innerText=hits[0].object.userData.info.name;} 
                else t.style.display='none';
                renderer.render(scene, camera);
            }
            else if(currentState==='MINECRAFT') {
                mcUpdateDayCycle();
                // Ruch kamery (Latanie/Chodzenie proste)
                const speed = 0.15;
                const front = new THREE.Vector3(Math.sin(camTheta), 0, Math.cos(camTheta));
                const right = new THREE.Vector3(Math.sin(camTheta + Math.PI/2), 0, Math.cos(camTheta + Math.PI/2));
                
                if(keys.w) camera.position.add(front.multiplyScalar(-speed));
                if(keys.s) camera.position.add(front.multiplyScalar(speed));
                if(keys.a) camera.position.add(right.multiplyScalar(-speed));
                if(keys.d) camera.position.add(right.multiplyScalar(speed));
                if(keys.space) camera.position.y += 0.1; // Proste latanie do góry
                // Grawitacja (bardzo prosta, żeby nie utknąć w blokach)
                if(!keys.space && camera.position.y > 2) {
                     // Sprawdź czy jest blok pod nogami
                     const footPos = camera.position.clone(); footPos.y -= 2;
                     const key = Math.round(footPos.x)+','+Math.round(footPos.y)+','+Math.round(footPos.z);
                     if(!mcWorld[key]) camera.position.y -= 0.1;
                }

                camera.lookAt(camera.position.x - Math.sin(camTheta), camera.position.y + Math.cos(camPhi), camera.position.z - Math.cos(camTheta));
                renderer.render(scene, camera);
            }
            else if(currentState==='OBBY') {
                const speed=0.15;
                const dx = (Number(keys.d)-Number(keys.a)), dz = (Number(keys.s)-Number(keys.w));
                if(dx!==0 || dz!==0) {
                    const sin = Math.sin(camTheta), cos = Math.cos(camTheta);
                    const vx = (dx*cos + dz*sin)*speed; const vz = (-dx*sin + dz*cos)*speed;
                    playerGroup.position.x += vx; playerGroup.position.z += vz;
                    playerGroup.rotation.y = Math.atan2(vx, vz) + Math.PI;
                    const t = Date.now()*0.02;
                    playerGroup.children[0].children[2].rotation.x = Math.sin(t);
                    playerGroup.children[0].children[3].rotation.x = -Math.sin(t);
                }
                playerGroup.position.y += velocityY; velocityY -= 0.015; onGround=false;
                
                const feetY = playerGroup.position.y;
                for(let p of platforms) {
                    if(Math.abs(p.position.z - playerGroup.position.z) > 6) continue;
                    const bounds = new THREE.Box3().setFromObject(p);
                    const margin = 0.3; // TRUDNE LĄDOWANIE
                    if(playerGroup.position.x > bounds.min.x - margin && playerGroup.position.x < bounds.max.x + margin &&
                       playerGroup.position.z > bounds.min.z - margin && playerGroup.position.z < bounds.max.z + margin) {
                        if(feetY >= bounds.max.y-0.5 && feetY <= bounds.max.y+1.0 && velocityY<=0) {
                            playerGroup.position.y = bounds.max.y; velocityY=0; onGround=true;
                            if(p.userData.checkpoint && p.position.z < obbyCheckpoint.z-2) {
                                obbyCheckpoint.copy(playerGroup.position).add(new THREE.Vector3(0,0.1,0));
                                const info = document.getElementById('checkpoint-info');
                                info.style.display='block'; setTimeout(()=>info.style.display='none',2000);
                            }
                        }
                    }
                }
                if(playerGroup.position.y < -15) { playerGroup.position.copy(obbyCheckpoint); velocityY=0; }
                const cd = 6;
                camera.position.set(
                    playerGroup.position.x + Math.sin(camTheta)*Math.sin(camPhi)*cd,
                    playerGroup.position.y + Math.cos(camPhi)*cd,
                    playerGroup.position.z + Math.cos(camTheta)*Math.sin(camPhi)*cd
                );
                camera.lookAt(playerGroup.position.x, playerGroup.position.y+0.5, playerGroup.position.z);
                renderer.render(scene, camera);
            }
        }
    </script>
</body>
</html>
